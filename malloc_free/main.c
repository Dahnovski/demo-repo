/*
 * malloc() and free()
 *
 * Раньше была память, работала одна программа в один момент времени
 * и программист мог свободно ее испольовать.
 * А потом появились многозадачные ОС с параллельным выполнением сразу нескольких программ
 * Теперь программа не может размещать данные по своему усмотрению. Эти ячейки могут быть заняты.
 * Был создан посредник — менеджер памяти.
 * Выделяем память и освобождение, чтоб потом ей можно было пользоваться (иначе утечка памяти)
 * */

#include <stdio.h>
#include <stdlib.h>
/*
 * функция принимает массив, его длину (через указатель), капасити и значение которое записываем в массив
 * ФУНКЦИЯ ВОЗВРАЩАЕТ АДРЕС*/
void* append(short *data, size_t *length, size_t *capacity, short value)
{
    /*если длина поджимает то увелдичиваем длину и создаем новый массив*/
    if(*length >= *capacity) {
        /*
         * если длина поджимает, то увеличиваем в 2 раза вместимость
         * увеличивая капасити и СОЗДАЕМ НОВЫЙ МАССИВ*/
        /**/
        short *ar = malloc(sizeof(short) * 2 * *capacity);

        // проверка на ошибку (проверка выделена ли память по адресу или вместо адреса NULL_ptr)
        if(ar == NULL) {
            /*поэтому просто вернем указатель на прежний массив и больше ничего не будем делать*/
            return data;
        }

        /*если все ок то копируем все данные из прежнего массива в новый массив*/
        (*capacity) *= 2;
        for (int i = 0; i < *length; ++i) {
            ar[i] = data[i];
        }
        // ТУТ СТОП! 13:40
        /*освободили память из прежнего массива на который ведет указатель data*/
        free(data);
        /*и присвоили data новый указатель (АДРЕС НОВОГО МАССИВА) на наш сформированный массив*/
        data = ar;
    }

    /*запишем последнее значение в наш массив*/
    data[*length] = value;
    (*length)++;

    /*и вернем адрес на массив потому что после заполнения массива его адрес меняется
     * поэтому передаем актуальный*/
    return data;
}

int
main()
{
    /*воспользуемся первой функцией чтоб выделить 10 байт из памяти (кучи)
     * на эту свободную память ссылается адрес ar*/


    //char *ar = malloc(10); // NULL если не выделится
    //int *ptr_int = malloc(sizeof(int));

    /*освобождаем столько — раз сколько выдляем*/
    //free(ar);
    //free(ptr_int);

    /* утечка памяти это наращивание занимаемой и отсутствие освобождения */

    /*сделаем динамический массив для примера использования функции malloc() and free()*/

    size_t capacity = 10;
    size_t length = 0;

    /*число байт которое нам нужно для массива будет увеличиваться по мере заполнения
     *умножаем шорт на количество байт которое нам нужно и получаем непрерывную область памяти под наш массив
     *
     * МЫ НЕ РАСХОДУЕМ ПАМЯТЬ, А УВЕЛИЧИВАЕМ ЕЕ ПО МЕРЕ ТОГО КАК ОНА ЗАПОЛНЯЕТСЯ*/
    short *data = malloc(sizeof(short) * capacity);

    /*в цикле добавляем данные*/
    for (int i = 0; i < 11; ++i) {
        /*функция добавляет новые значения в массив data
         * КОГДА ИДЁТ ВЫЗОВ ФУНКЦИИ МЫ ВОЗВРАЩАЕМ МАССИВ DATA*/
        data = append(data, &length, &capacity, rand() % 40 - 20);
    }

    printf("Length = %u, Capacity = %u\n", length, capacity);

    for (int i = 0; i < length; ++i) {
        printf("%d ", data[i]);
    }

    free(data);

    return 0;
}
